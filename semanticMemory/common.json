{
  "moduleName": "reconengine-common",
  "description": "Common library module for the Reconciliation Engine providing shared utilities, DTOs, and cross-cutting concerns across microservices",
  "version": "1.0.0",
  "dependencyVersions": {
    "javaVersion": "21",
    "springBoot": "3.2.6",
    "resilience4j": "2.1.0",
    "junit": "5.10.0",
    "jackson": "2.15.4",
    "jjwt": "0.11.5",
    "micrometer": "1.13.1",
    "esapi": "2.2.0.0",
    "mockito": "5.18.0",
    "avro": "1.11.3",
    "kafka": "3.6.2",
    "logback": "1.4.14",
    "openTelemetry": "1.38.0"
  },
  "buildTools": {
    "maven": {
      "plugins": [
        "maven-surefire-plugin 3.2.5",
        "maven-compiler-plugin 3.14.0",
        "spring-boot-maven-plugin 3.2.6",
        "avro-maven-plugin 1.11.3",
        "jacoco-maven-plugin 0.8.13",
        "spotless-maven-plugin 2.44.5"
      ],
      "buildCommands": {
        "standard": "mvn clean install",
        "skipTests": "mvn clean install -DskipTests",
        "skipITs": "mvn clean install -DskipITs",
        "offlineMode": "mvn clean install -o",
        "debugMode": "mvn clean install -X",
        "specificModule": "mvn clean install -pl common -am"
      },
      "buildBehavior": {
        "cleanInstall": {
          "description": "Standard build lifecycle that cleans previous builds, compiles code, runs tests, packages artifacts, and installs to local repository",
          "phases": [
            "clean - Removes all files generated by the previous build",
            "validate - Validates project correctness",
            "compile - Compiles source code",
            "test - Runs unit tests",
            "package - Packages compiled code into distributable format (JAR)",
            "verify - Runs integration tests and checks package validity",
            "install - Installs package to local repository for use as dependency"
          ],
          "observedIssues": [
            "Compilation errors in test code due to missing Mockito static imports",
            "Missing MockedStatic and LoggerFactory symbols in DlqRouterTest.java",
            "Build fails during test compilation phase"
          ],
          "generatedArtifacts": [
            "common/target/common-1.0.0-SNAPSHOT.jar",
            "common/target/classes/",
            "common/target/test-classes/"
          ]
        },
        "skipTests": {
          "description": "Skips execution of test phase but still compiles test classes",
          "command": "mvn clean install -DskipTests",
          "behavior": "Compiles main and test sources but doesn't execute any tests",
          "observedBehavior": "Still fails due to test compilation errors - does not skip test compilation"
        },
        "skipTestCompilation": {
          "description": "Skips both test compilation and execution",
          "command": "mvn clean install -Dmaven.test.skip=true",
          "behavior": "Skips test compilation and execution entirely",
          "observedBehavior": "Successfully builds and installs the artifact without running or compiling tests",
          "generatedArtifacts": [
            "common/target/common-1.0.0-SNAPSHOT.jar",
            "common/target/classes/"
          ],
          "skippedPhases": [
            "testResources - Not copying test resources",
            "testCompile - Not compiling test sources",
            "test - Tests are skipped",
            "JaCoCo report and check - Skipped due to missing execution data file"
          ]
        },
        "testOutput": {
          "logFiles": [
            "common/logs/common-libraries.log",
            "common/logs/common-libraries.log.2025-07-10.0.log",
            "common/logs/common-libraries.log.2025-07-11.0.log"
          ],
          "format": "JSON structured logging via logback"
        }
      }
    }
  },
  "mainComponents": {
    "applicationEntry": {
      "name": "CommonApplication",
      "description": "Main entry point for the Reconciliation Engine Common Libraries Spring Boot application",
      "path": "src/main/java/com/grace/recon/common/CommonApplication.java"
    },
    "configuration": {
      "appConfig": {
        "name": "AppConfig",
        "description": "Core application configuration properties",
        "path": "src/main/java/com/grace/recon/common/config/AppConfig.java",
        "properties": ["kafkaBootstrapServers", "commonBufferCapacity"]
      },
      "featureFlagService": {
        "name": "FeatureFlagService",
        "description": "Service for managing feature flags to enable/disable functionality",
        "path": "src/main/java/com/grace/recon/common/config/FeatureFlagService.java",
        "features": ["newMatchingAlgorithm", "detailedAuditLogging"]
      },
      "secretManager": {
        "name": "SecretManager",
        "description": "Interface for accessing secrets and sensitive configuration values",
        "path": "src/main/java/com/grace/recon/common/config/SecretManager.java",
        "implementations": ["PoCSecretManager"]
      }
    },
    "dataModels": {
      "core": {
        "quant": {
          "name": "Quant",
          "description": "Core data model representing a transaction or financial data point",
          "path": "src/main/java/com/grace/recon/common/dto/Quant.java",
          "fields": [
            "transactionId", "amount", "currency", "transactionDate", 
            "description", "sourceSystem", "transactionType", 
            "authorizationCode", "sourceReferenceId", "accountId", 
            "additionalMetadata"
          ]
        },
        "quantPair": {
          "name": "QuantPair",
          "description": "Pair of Quant objects to be reconciled (husband and wife)",
          "path": "src/main/java/com/grace/recon/common/dto/QuantPair.java",
          "fields": ["husband", "wife"]
        }
      },
      "matching": {
        "matchedQuant": {
          "name": "MatchedQuant",
          "description": "Result of an exact match between two Quant objects",
          "path": "src/main/java/com/grace/recon/common/dto/MatchedQuant.java",
          "fields": ["quantPair", "matchStatus"]
        },
        "fuzzyMatchedQuant": {
          "name": "FuzzyMatchedQuant",
          "description": "Result of a fuzzy match between two Quant objects with confidence score",
          "path": "src/main/java/com/grace/recon/common/dto/FuzzyMatchedQuant.java",
          "fields": ["quantPair", "matchStatus", "confidenceScore"]
        }
      },
      "output": {
        "matchResult": {
          "name": "MatchResult",
          "description": "Structured output of a successful matching attempt",
          "path": "src/main/java/com/grace/recon/common/dto/output/MatchResult.java",
          "fields": ["quantPair", "matchType", "confidenceScore", "fuzzyMatchDetails"],
          "enums": {
            "matchType": ["EXACT", "FUZZY"]
          }
        },
        "ureQuant": {
          "name": "UreQuant",
          "description": "Unreconciled Exception (URE) representing a failed match",
          "path": "src/main/java/com/grace/recon/common/dto/output/UreQuant.java",
          "fields": ["quantPair", "reasonCode", "errorDetails", "timestamp"]
        },
        "reconMeta": {
          "name": "ReconMeta",
          "description": "Metadata about a reconciliation batch for reporting",
          "path": "src/main/java/com/grace/recon/common/dto/output/ReconMeta.java",
          "fields": [
            "batchId", "processingStartTime", "processingEndTime", 
            "processingDurationMs", "totalPairsProcessed", "exactMatchCount", 
            "fuzzyMatchCount", "ureCount"
          ]
        }
      }
    },
    "errorHandling": {
      "exceptions": {
        "reconciliationException": {
          "name": "ReconciliationException",
          "description": "Base custom exception for all reconciliation-specific business errors",
          "path": "src/main/java/com/grace/recon/common/error/ReconciliationException.java"
        },
        "dataFormatException": {
          "name": "DataFormatException",
          "description": "Exception thrown when data is found to be in an unexpected or malformed format",
          "path": "src/main/java/com/grace/recon/common/error/DataFormatException.java",
          "extends": "ReconciliationException"
        },
        "kafkaProducerException": {
          "name": "KafkaProducerException",
          "description": "Exception thrown when an error occurs during Kafka producer operations",
          "path": "src/main/java/com/grace/recon/common/error/KafkaProducerException.java",
          "extends": "ReconciliationException"
        },
        "validationException": {
          "name": "ValidationException",
          "description": "Custom exception specifically for validation failures",
          "path": "src/main/java/com/grace/recon/common/validation/ValidationException.java",
          "extends": "ReconciliationException"
        }
      },
      "errorCodes": {
        "name": "ErrorCode",
        "description": "Enumeration of standardized error codes across the entire system",
        "path": "src/main/java/com/grace/recon/common/dto/ErrorCode.java",
        "categories": [
          "General Errors", "Validation Errors", "Matching Errors", 
          "Data Format/Parsing Errors", "External System Integration Errors", 
          "Business Logic Errors", "PCI Compliance Errors", "Resilience Errors"
        ]
      },
      "errorCategory": {
        "name": "ErrorCategory",
        "description": "Enumeration for categorizing different types of errors",
        "path": "src/main/java/com/grace/recon/common/error/ErrorCategory.java",
        "values": ["TRANSIENT", "PERMANENT", "BUSINESS_LOGIC", "SECURITY", "UNKNOWN"]
      },
      "dlqRouter": {
        "name": "DlqRouter",
        "description": "Implements logic for routing failed messages to Dead Letter Queues (DLQs)",
        "path": "src/main/java/com/grace/recon/common/error/DlqRouter.java",
        "methods": ["routeToDlq"]
      },
      "traceIdInjector": {
        "name": "TraceIdInjector",
        "description": "Utility for injecting and managing trace IDs for distributed tracing",
        "path": "src/main/java/com/grace/recon/common/error/TraceIdInjector.java",
        "methods": ["injectNewTraceId", "injectTraceId", "getCurrentTraceId", "clearTraceId"]
      }
    },
    "monitoring": {
      "structuredLogger": {
        "name": "StructuredLogger",
        "description": "Logger that adds structured context data to log messages",
        "path": "src/main/java/com/grace/recon/common/monitoring/StructuredLogger.java",
        "methods": ["info", "warn", "error", "debug", "trace"],
        "features": {
          "mdcSupport": "Uses SLF4J MDC for structured logging",
          "contextPreservation": "Ensures MDC context is cleared after logging",
          "logLevels": ["INFO", "WARN", "ERROR", "DEBUG", "TRACE"],
          "structuredData": "Supports key-value pairs in log context"
        }
      },
      "auditLogger": {
        "name": "AuditLogger",
        "description": "Dedicated logger for critical audit events",
        "path": "src/main/java/com/grace/recon/common/monitoring/AuditLogger.java",
        "methods": ["logEvent"],
        "features": {
          "dedicatedLogger": "Uses separate 'AUDIT' logger instance",
          "structuredLogging": "Supports key-value pairs via MDC",
          "contextIsolation": "Ensures audit context is cleared after logging"
        }
      },
      "metricService": {
        "name": "MetricService",
        "description": "Service for publishing custom metrics using Micrometer",
        "path": "src/main/java/com/grace/recon/common/monitoring/MetricService.java",
        "methods": [
          "incrementCounter",
          "registerGauge",
          "recordTimer"
        ],
        "metricTypes": {
          "counter": "Tracks count of events",
          "gauge": "Reports current value of a metric",
          "timer": "Measures duration of operations"
        },
        "features": {
          "tagging": "Supports dimensional metrics via tags",
          "customMetrics": "Allows registration of application-specific metrics",
          "timerSupport": "Records timing for both Callable and Runnable operations"
        }
      },
      "traceService": {
        "name": "TraceService",
        "description": "Service for managing and creating OpenTelemetry spans and traces",
        "path": "src/main/java/com/grace/recon/common/monitoring/TraceService.java",
        "methods": [
          "startSpan",
          "startAndMakeCurrentSpan",
          "endSpan",
          "recordException",
          "getCurrentSpan"
        ],
        "features": {
          "distributedTracing": "Enables tracing across microservices",
          "spanManagement": "Full span lifecycle management",
          "errorTracking": "Records exceptions in trace context",
          "contextPropagation": "Maintains trace context across async boundaries"
        }
      }
    },
    "validation": {
      "validator": {
        "name": "Validator",
        "description": "Generic interface for defining custom data validation logic",
        "path": "src/main/java/com/grace/recon/common/validation/Validator.java",
        "methods": ["validate"],
        "innerClasses": ["ValidationResult"]
      },
      "ruleResult": {
        "name": "RuleResult",
        "description": "Encapsulates the outcome of a single validation rule execution",
        "path": "src/main/java/com/grace/recon/common/validation/RuleResult.java",
        "methods": ["passed", "failed"]
      },
      "yamlRuleEngine": {
        "name": "YamlRuleEngine",
        "description": "Core component that interprets and executes dynamic validation rules defined in YAML",
        "path": "src/main/java/com/grace/recon/common/validation/YamlRuleEngine.java",
        "methods": ["loadRules", "validate"],
        "ruleTypes": {
          "presence": "Validates field existence",
          "value": "Validates field value against expected value"
        },
        "predefinedRules": {
          "quant-validation-rules": {
            "rule-1": {
              "field": "transactionId",
              "type": "presence"
            },
            "rule-2": {
              "field": "amount",
              "type": "presence"
            },
            "rule-3": {
              "field": "currency",
              "type": "value",
              "expectedValue": "USD"
            },
            "rule-4": {
              "field": "sourceSystem",
              "type": "presence"
            }
          },
          "ure-validation-rules": {
            "rule-a": {
              "field": "ureId",
              "type": "presence"
            },
            "rule-b": {
              "field": "transactionQuant",
              "type": "presence"
            },
            "rule-c": {
              "field": "reasonCode",
              "type": "presence"
            }
          }
        }
      }
    },
    "security": {
      "encryption": {
        "aesGcmEncryptor": {
          "name": "AesGcmEncryptor",
          "description": "Utility class for AES-GCM encryption and decryption",
          "path": "src/main/java/com/grace/recon/common/security/AesGcmEncryptor.java",
          "methods": [
            "generateAesKey", "encrypt", "decrypt", 
            "decodeKey", "encodeKey"
          ]
        }
      },
      "jwt": {
        "jwtUtil": {
          "name": "JwtUtil",
          "description": "Utility class for handling JSON Web Tokens (JWT)",
          "path": "src/main/java/com/grace/recon/common/security/JwtUtil.java",
          "methods": [
            "extractUsername", "extractExpiration", "extractClaim", 
            "generateToken", "createToken", "validateToken"
          ]
        }
      },
      "tls": {
        "tlsConfig": {
          "name": "TlsConfig",
          "description": "Utility class for configuring TLS/SSL contexts",
          "path": "src/main/java/com/grace/recon/common/security/TlsConfig.java",
          "methods": ["createSSLContext"]
        }
      },
      "sanitization": {
        "inputSanitizer": {
          "name": "InputSanitizer",
          "description": "Utility for sanitizing user input to prevent security vulnerabilities",
          "path": "src/main/java/com/grace/recon/common/security/InputSanitizer.java",
          "methods": [
            "sanitizeHtml", "sanitizeSql", "sanitizeUrl", 
            "sanitizeFilePath"
          ]
        }
      }
    },
    "pci": {
      "panMasker": {
        "name": "PanMasker",
        "description": "Utility class for masking sensitive Primary Account Numbers (PANs)",
        "path": "src/main/java/com/grace/recon/common/pci/PanMasker.java",
        "methods": ["maskPan", "maskPanShowFirstSixLastFour"]
      },
      "luhnValidator": {
        "name": "LuhnValidator",
        "description": "Implements the Luhn algorithm for basic validation of credit card numbers",
        "path": "src/main/java/com/grace/recon/common/pci/LuhnValidator.java",
        "methods": ["isValid"]
      },
      "expiryValidator": {
        "name": "ExpiryValidator",
        "description": "Utility class for validating credit card expiry dates",
        "path": "src/main/java/com/grace/recon/common/pci/ExpiryValidator.java",
        "methods": ["isValid"]
      },
      "pciAuditService": {
        "name": "PciAuditService",
        "description": "Service for publishing PCI audit events",
        "path": "src/main/java/com/grace/recon/common/pci/PciAuditService.java",
        "methods": ["logPciEvent"]
      }
    },
    "resilience": {
      "circuitBreaker": {
        "name": "CircuitBreakerConfiguration",
        "description": "Configuration class for Resilience4j Circuit Breaker patterns",
        "path": "src/main/java/com/grace/recon/common/resilience/CircuitBreakerConfiguration.java",
        "methods": [
          "externalServiceCircuitBreakerConfig", 
          "defaultCircuitBreakerConfig"
        ],
        "configurations": {
          "externalService": {
            "failureRateThreshold": 50,
            "waitDurationInOpenState": "10000ms",
            "slidingWindowType": "COUNT_BASED",
            "slidingWindowSize": 100,
            "minimumNumberOfCalls": 10
          }
        }
      },
      "retry": {
        "name": "RetryConfiguration",
        "description": "Configuration class for Resilience4j Retry patterns",
        "path": "src/main/java/com/grace/recon/common/resilience/RetryConfiguration.java",
        "methods": [
          "transientErrorRetryConfig",
          "defaultRetryConfig"
        ],
        "configurations": {
          "transientError": {
            "maxAttempts": 3,
            "intervalFunction": "1000ms fixed interval",
            "retryableExceptions": ["IOException", "TimeoutException"]
          }
        }
      },
      "timeLimiter": {
        "name": "TimeLimiterConfiguration",
        "description": "Configuration class for Resilience4j TimeLimiter patterns",
        "path": "src/main/java/com/grace/recon/common/resilience/TimeLimiterConfiguration.java",
        "methods": [
          "longRunningOperationTimeLimiterConfig",
          "defaultTimeLimiterConfig"
        ],
        "configurations": {
          "longRunningOperation": {
            "timeoutDuration": "5s",
            "cancelRunningFuture": true
          }
        }
      },
      "aspects": {
        "name": "ResilienceAspects",
        "description": "Spring AOP aspects to apply Resilience4j annotations to methods",
        "path": "src/main/java/com/grace/recon/common/resilience/ResilienceAspects.java",
        "methods": [
          "circuitBreakerAroundAdvice",
          "retryAroundAdvice",
          "timeLimiterAroundAdvice"
        ],
        "annotations": [
          "@CircuitBreaker",
          "@Retry",
          "@TimeLimiter"
        ]
      }
    }
  },
  "testing": {
    "configTests": [
      "AppConfigTest", 
      "FeatureFlagServiceTest", 
      "SecretManagerTest"
    ],
    "dtoTests": [
      "ErrorCodeTest"
    ],
    "errorTests": [
      "DlqRouterTest", 
      "ReconciliationExceptionTest", 
      "TraceIdInjectorTest"
    ],
    "monitoringTests": [
      "AuditLoggerTest", 
      "MetricServiceTest", 
      "StructuredLoggerTest", 
      "TraceServiceTest"
    ],
    "pciTests": [
      "ExpiryValidatorTest", 
      "LuhnValidatorTest", 
      "PanMaskerTest", 
      "PciAuditServiceTest"
    ],
    "resilienceTests": [
      "ResilienceAspectsIntegrationTest", 
      "ResilienceConfigTest"
    ],
    "securityTests": [
      "AesGcmEncryptorTest", 
      "InputSanitizerTest", 
      "JwtUtilTest", 
      "TlsConfigTest"
    ],
    "validationTests": [
      "ValidatorTest", 
      "YamlRuleEngineTest"
    ],
    "testExecution": {
      "framework": "JUnit 5.10.0",
      "runner": "maven-surefire-plugin 3.2.5",
      "configuration": {
        "includes": ["**/*Test.java"],
        "excludes": [],
        "parallelExecution": true,
        "reuseForks": true,
        "forkCount": 1
      },
      "coverage": {
        "tool": "JaCoCo 0.8.13",
        "thresholds": {
          "instruction": 0.80,
          "branch": 0.70,
          "line": 0.80,
          "method": 0.80,
          "class": 0.90
        },
        "excludes": [
          "**/dto/**",
          "**/CommonApplication.java"
        ],
        "reports": {
          "html": "target/site/jacoco",
          "xml": "target/site/jacoco/jacoco.xml"
        }
      },
      "skipBehavior": {
        "skipTests": {
          "description": "Skips test execution but still compiles test classes",
          "command": "mvn clean install -DskipTests",
          "affectedPhases": ["test", "verify"],
          "observedBehavior": "Does not skip test compilation; build fails if test compilation errors exist"
        },
        "skipITs": {
          "description": "Skips integration tests only",
          "command": "mvn clean install -DskipITs",
          "affectedPhases": ["verify"],
          "observedBehavior": "Not tested, but likely still requires successful test compilation"
        },
        "maven.test.skip": {
          "description": "Skips test compilation and execution",
          "command": "mvn clean install -Dmaven.test.skip=true",
          "affectedPhases": ["test-compile", "test", "verify"],
          "observedBehavior": "Successfully skips test compilation and execution; allows build to succeed even with test compilation issues"
        },
        "jacoco": {
          "description": "JaCoCo behavior with skipped tests",
          "observedBehavior": "JaCoCo report and check phases are skipped when tests are not executed due to missing execution data file"
        }
      },
      "environmentSetup": {
        "testResources": [
          "application.yml",
          "ESAPI.properties",
          "logback-test.xml"
        ],
        "profiles": ["test"],
        "javaVersion": "21.0.7"
      }
    }
  },
  "technicalStack": {
    "frameworks": [
      "Spring Boot 3.2.6",
      "Resilience4j 2.1.0",
      "Micrometer 1.13.1",
      "OpenTelemetry 1.38.0",
      "JJWT 0.11.5",
      "ESAPI 2.2.0.0"
    ],
    "dataFormats": [
      "JSON",
      "YAML",
      "Avro 1.11.3"
    ],
    "messaging": [
      "Kafka 3.6.2",
      "Spring Kafka 3.2.3"
    ],
    "security": [
      "AES-GCM Encryption",
      "JWT",
      "TLS",
      "Input Sanitization",
      "PCI Compliance"
    ],
    "observability": [
      "Structured Logging (Logback 1.4.14)",
      "Metrics (Micrometer 1.13.1)",
      "Distributed Tracing (OpenTelemetry 1.38.0)"
    ],
    "testing": [
      "JUnit 5.10.0",
      "Mockito 5.18.0",
      "Spring Kafka Test 3.2.3"
    ]
  },
  "businessDomain": {
    "purpose": "Financial transaction reconciliation and matching",
    "keyFunctionality": [
      "Exact matching of transaction pairs",
      "Fuzzy matching with confidence scores",
      "Error handling and dead letter queue routing",
      "PCI compliance for sensitive financial data",
      "Validation through configurable rule engines",
      "Resilience patterns for external system integration",
      "Security utilities for data protection"
    ]
  },
  "testIssues": {
    "criticalFailures": [
      {
        "issueType": "StaticMockingDependency",
        "description": "Missing mockito-inline dependency required for mocking static methods",
        "affectedTests": [
          "DlqRouterTest",
          "AuditLoggerTest",
          "PciAuditServiceTest",
          "TraceServiceTest"
        ],
        "error": "cannot find symbol: class MockedStatic",
        "resolution": "Add mockito-inline dependency to the pom.xml file",
        "dependencyToAdd": "<dependency>\n  <groupId>org.mockito</groupId>\n  <artifactId>mockito-inline</artifactId>\n  <version>${mockito.version}</version>\n  <scope>test</scope>\n</dependency>",
        "atomicAnalysis": {
          "DlqRouterTest": {
            "failurePoint": "Line 24-25: try (MockedStatic<LoggerFactory> mockedLoggerFactory = Mockito.mockStatic(LoggerFactory.class))",
            "rootCause": "Cannot mock static LoggerFactory.getLogger() call",
            "impact": "Unable to verify logging behavior in DLQ routing"
          },
          "AuditLoggerTest": {
            "failurePoint": "Line 29: mockedLoggerFactory = Mockito.mockStatic(LoggerFactory.class)",
            "rootCause": "Cannot create static mock for LoggerFactory",
            "impact": "Cannot verify audit logging behavior"
          },
          "PciAuditServiceTest": {
            "failurePoint": "Line 19: mockedAuditLogger = Mockito.mockStatic(AuditLogger.class)",
            "rootCause": "Cannot mock static AuditLogger methods",
            "impact": "Unable to verify PCI audit event logging"
          },
          "TraceServiceTest": {
            "failurePoint": "Line 74: MockedStatic<Span> mockedSpan = Mockito.mockStatic(Span.class)",
            "rootCause": "Cannot mock static Span.current() method",
            "impact": "Unable to test current span retrieval"
          }
        }
      },
      {
        "issueType": "LoggingConfiguration",
        "description": "Incompatible test logging configuration",
        "details": "The logback-spring.xml in src/main/resources is configured for production JSON logging using net.logstash.logback.encoder.LogstashEncoder. This dependency is not available on the test classpath.",
        "atomicAnalysis": {
          "failurePoint": "Test context initialization",
          "stackTrace": "java.lang.ClassNotFoundException: net.logstash.logback.encoder.LogstashEncoder",
          "impactedTests": [
            "StructuredLoggerTest",
            "AuditLoggerTest",
            "MetricServiceTest"
          ],
          "resolution": {
            "step1": "Create logback-test.xml in src/test/resources",
            "step2": "Configure ConsoleAppender with PatternLayout for tests",
            "step3": "Remove Logstash dependency from test scope"
          }
        }
      }
    ],
    "testDesignIssues": [
      {
        "issueType": "StaticMockingLeaks",
        "description": "Static mocks not properly cleaned up between tests",
        "atomicAnalysis": {
          "AuditLoggerTest": {
            "leakPoint": "Line 34: mockedLoggerFactory.close()",
            "issue": "MockedStatic resource not always closed if test fails",
            "impact": "State leaks between tests causing false positives/negatives"
          },
          "PciAuditServiceTest": {
            "leakPoint": "Missing cleanup in @AfterEach",
            "issue": "No explicit cleanup of static mocks",
            "impact": "Interferes with subsequent test execution"
          }
        }
      },
      {
        "issueType": "FlawedAssertions",
        "description": "Multiple tests contain incorrect assertions",
        "atomicAnalysis": {
          "LuhnValidatorTest": {
            "failurePoint": "Line 12-14: assertTrue(LuhnValidator.isValid())",
            "issue": "Test data contains invalid Luhn numbers marked as valid",
            "fix": "Update test data with correct Luhn algorithm numbers"
          },
          "ResilienceConfigTest": {
            "failurePoint": "Line 31-32: Duration comparison",
            "issue": "Direct comparison of Duration objects with primitive values",
            "fix": "Use Duration.equals() or toMillis() for comparison"
          },
          "ResilienceAspectsIntegrationTest": {
            "failurePoint": {
              "testRetrySuccess": {
                "line": "89-93",
                "issue": "Incorrect retry count assertion",
                "fix": "Account for successful first attempt"
              },
              "testTimeLimiterTimeout": {
                "line": "106-110",
                "issue": "Race condition in timeout test",
                "fix": "Use awaitability pattern with reasonable timeout"
              }
            }
          }
        }
      },
      {
        "issueType": "RaceCondition",
        "description": "Timing-dependent tests in multiple classes",
        "atomicAnalysis": {
          "ResilienceAspectsIntegrationTest": {
            "failurePoint": "Line 106: testTimeLimiterTimeout()",
            "issue": "Hard-coded sleep duration causes flaky tests",
            "fix": "Use awaitability pattern with configurable timeouts"
          },
          "MetricServiceTest": {
            "failurePoint": "Line 41-47: testRecordTimerCallable()",
            "issue": "Thread.sleep() makes test duration dependent",
            "fix": "Mock time or use test clock"
          }
        }
      }
    ],
    "buildSystemIssues": [
      {
        "issueType": "DependencyConflict",
        "description": "Version conflicts in test dependencies",
        "atomicAnalysis": {
          "mockito": {
            "issue": "mockito-core vs mockito-inline version mismatch",
            "impact": "Static mocking functionality broken",
            "resolution": "Align versions in dependency management"
          },
          "logback": {
            "issue": "logback-classic version conflict between parent and child POM",
            "impact": "Logging configuration issues in tests",
            "resolution": "Remove explicit version in child POM"
          }
        }
      },
      {
        "issueType": "TestResourceConfiguration",
        "description": "Incorrect test resource handling",
        "atomicAnalysis": {
          "logback": {
            "issue": "Missing test-specific logging configuration",
            "impact": "Tests fail due to missing Logstash encoder",
            "resolution": "Add logback-test.xml to src/test/resources"
          },
          "ESAPI": {
            "issue": "Incorrect ESAPI logger configuration in test",
            "impact": "Security logging fails in tests",
            "resolution": "Update ESAPI.properties in test resources"
          }
        }
      }
    ],
    "observedBehavior": {
      "mvnCleanInstall": {
        "outcome": "Failure",
        "phase": "test-compile",
        "error": "cannot find symbol: class MockedStatic",
        "atomicCause": "Missing mockito-inline dependency"
      },
      "mvnCleanInstallSkipTests": {
        "outcome": "Failure",
        "phase": "test-compile",
        "error": "cannot find symbol: class MockedStatic",
        "atomicCause": "Test classes still compiled even with -DskipTests"
      },
      "mvnCleanInstallMavenTestSkip": {
        "outcome": "Success",
        "reason": "Skips test compilation entirely",
        "warning": "Masks underlying test issues"
      }
    }
  },
  "cicd": {
    "buildPipeline": {
      "provider": "Jenkins",
      "stages": [
        {
          "name": "checkout",
          "description": "Retrieves source code from Git repository"
        },
        {
          "name": "build",
          "description": "Compiles source code and runs tests",
          "command": "mvn clean install"
        },
        {
          "name": "quality",
          "description": "Runs code quality checks and security scans",
          "commands": [
            "mvn spotless:check",
            "mvn org.owasp:dependency-check-maven:check"
          ]
        },
        {
          "name": "package",
          "description": "Creates deployable artifacts",
          "command": "mvn package -DskipTests"
        },
        {
          "name": "publish",
          "description": "Publishes artifacts to artifact repository",
          "command": "mvn deploy -DskipTests"
        }
      ],
      "triggers": ["push to main", "pull request", "scheduled nightly"]
    },
    "deploymentPipeline": {
      "environments": [
        {
          "name": "development",
          "deploymentStrategy": "automatic",
          "trigger": "successful build on main branch"
        },
        {
          "name": "testing",
          "deploymentStrategy": "automatic",
          "trigger": "successful deployment to development"
        },
        {
          "name": "staging",
          "deploymentStrategy": "manual approval",
          "trigger": "successful testing in test environment"
        },
        {
          "name": "production",
          "deploymentStrategy": "manual approval",
          "trigger": "successful testing in staging environment"
        }
      ]
    },
    "artifactManagement": {
      "repository": "Nexus",
      "artifacts": [
        {
          "name": "common-1.0.0-SNAPSHOT.jar",
          "type": "library jar",
          "path": "common/target/common-1.0.0-SNAPSHOT.jar"
        }
      ],
      "dependencies": "Managed through Maven Central and internal Nexus repository"
    }
  },
  "architecturalPatterns": {
    "aspectOrientedProgramming": {
      "aspects": {
        "resilience": {
          "pointcuts": [
            "@CircuitBreaker methods",
            "@Retry methods",
            "@TimeLimiter methods"
          ],
          "advices": {
            "circuitBreakerAroundAdvice": "Applies circuit breaking logic",
            "retryAroundAdvice": "Applies retry logic",
            "timeLimiterAroundAdvice": "Applies time limiting logic"
          },
          "implementation": "ResilienceAspects"
        }
      }
    },
    "decoratorPattern": {
      "implementations": {
        "structuredLogger": {
          "decorates": "SLF4J Logger",
          "addedBehavior": "Structured logging with MDC context"
        },
        "validator": {
          "decorates": "Basic validation",
          "addedBehavior": "Rule-based validation with YAML configuration"
        }
      }
    },
    "strategyPattern": {
      "implementations": {
        "errorHandling": {
          "strategies": [
            "TRANSIENT - Retry with backoff",
            "PERMANENT - Route to DLQ",
            "BUSINESS_LOGIC - Custom handling",
            "SECURITY - Audit and escalate"
          ]
        },
        "validation": {
          "strategies": [
            "Presence validation",
            "Value validation",
            "Custom rule validation"
          ]
        }
      }
    }
  },
  "crossCuttingConcerns": {
    "security": {
      "authentication": {
        "jwt": {
          "implementation": "JwtUtil",
          "features": [
            "Token generation",
            "Claims extraction",
            "Token validation",
            "Expiration handling"
          ],
          "securityMeasures": [
            "Uses HS256 algorithm",
            "Secure key management",
            "Expiration enforcement",
            "Claims validation"
          ]
        }
      },
      "inputSanitization": {
        "implementation": "InputSanitizer",
        "protectedContexts": {
          "html": "XSS prevention",
          "sql": "SQL injection prevention",
          "url": "URL manipulation prevention",
          "filePath": "Path traversal prevention"
        },
        "dependencies": {
          "esapi": "OWASP Enterprise Security API"
        }
      },
      "pciCompliance": {
        "dataProtection": {
          "panMasking": {
            "implementation": "PanMasker",
            "patterns": {
              "basic": "************1234",
              "detailed": "123456******1234"
            }
          }
        },
        "auditLogging": {
          "implementation": "PciAuditService",
          "events": [
            "PAN_ACCESS",
            "DATA_MASKING",
            "VALIDATION_FAILURE"
          ]
        }
      }
    },
    "observability": {
      "distributedTracing": {
        "implementation": "TraceService",
        "features": {
          "spanManagement": {
            "operations": [
              "startSpan",
              "startAndMakeCurrentSpan",
              "endSpan"
            ],
            "attributes": [
              "traceId",
              "spanId",
              "parentSpanId"
            ]
          },
          "errorTracking": {
            "capabilities": [
              "Exception recording",
              "Stack trace preservation",
              "Error categorization"
            ]
          },
          "contextPropagation": {
            "mechanisms": [
              "Explicit context passing",
              "Automatic context propagation",
              "Context restoration"
            ]
          }
        }
      },
      "metrics": {
        "implementation": "MetricService",
        "types": {
          "counter": {
            "usage": "Track occurrence count",
            "features": ["Monotonic", "Cumulative"]
          },
          "gauge": {
            "usage": "Track current value",
            "features": ["Point-in-time", "Bidirectional"]
          },
          "timer": {
            "usage": "Track duration",
            "features": ["Latency", "Throughput"]
          }
        },
        "dimensions": {
          "tagging": "Key-value pairs for metric segmentation",
          "aggregation": "Support for statistical aggregation",
          "exporters": ["Prometheus", "Micrometer"]
        }
      },
      "structuredLogging": {
        "implementation": "StructuredLogger",
        "features": {
          "contextEnrichment": {
            "mdc": {
              "usage": "Thread-local diagnostic context",
              "lifecycle": "Automatic cleanup"
            },
            "standardFields": [
              "timestamp",
              "level",
              "thread",
              "logger",
              "message"
            ],
            "customFields": "Dynamic key-value pairs"
          },
          "levels": {
            "trace": "Finest-grained information",
            "debug": "Debugging information",
            "info": "General information",
            "warn": "Warning messages",
            "error": "Error messages"
          }
        }
      }
    },
    "resilience": {
      "patterns": {
        "circuitBreaker": {
          "implementation": "CircuitBreakerConfiguration",
          "states": ["CLOSED", "OPEN", "HALF_OPEN"],
          "transitions": {
            "closed_to_open": "Failure rate exceeds threshold",
            "open_to_half_open": "Wait duration elapsed",
            "half_open_to_closed": "Success rate meets threshold",
            "half_open_to_open": "Failure rate still high"
          },
          "configurations": {
            "failureRateThreshold": "50%",
            "waitDurationInOpenState": "10000ms",
            "slidingWindowSize": "100 calls",
            "minimumNumberOfCalls": "10 calls"
          }
        },
        "retry": {
          "implementation": "RetryConfiguration",
          "strategy": {
            "maxAttempts": 3,
            "backoff": "Fixed interval 1000ms",
            "retryableExceptions": [
              "IOException",
              "TimeoutException"
            ]
          }
        },
        "timeLimiter": {
          "implementation": "TimeLimiterConfiguration",
          "configurations": {
            "timeoutDuration": "5s",
            "cancelOnTimeout": true
          }
        }
      },
      "fallbackStrategies": {
        "circuitBreaker": "Return cached/default value",
        "retry": "Use alternative service",
        "timeLimiter": "Return partial result"
      }
    }
  },
  "componentRelationships": {
    "validationChain": {
      "flow": [
        "Input data",
        "InputSanitizer",
        "YamlRuleEngine",
        "Validator",
        "ValidationResult"
      ],
      "errorHandling": [
        "ValidationException",
        "DlqRouter",
        "ErrorCategory"
      ]
    },
    "observabilityStack": {
      "flow": [
        "Application code",
        "StructuredLogger",
        "MetricService",
        "TraceService",
        "Monitoring systems"
      ],
      "correlations": {
        "traceId": "Links logs, metrics, and traces",
        "metricTags": "Connects metrics to traces",
        "logContext": "Enriches logs with trace/metric data"
      }
    },
    "securityLayers": {
      "flow": [
        "Input validation",
        "Authentication",
        "Authorization",
        "Data protection",
        "Audit logging"
      ],
      "integrations": {
        "authentication": ["JwtUtil", "SecretManager"],
        "dataProtection": ["PanMasker", "AesGcmEncryptor"],
        "auditLogging": ["PciAuditService", "AuditLogger"]
      }
    }
  },
  "dataFlows": {
    "validation": {
      "inputProcessing": {
        "sanitization": "InputSanitizer removes dangerous characters",
        "validation": "YamlRuleEngine applies business rules",
        "result": "ValidationResult captures outcome"
      },
      "errorHandling": {
        "validation": "ValidationException with detailed errors",
        "routing": "DlqRouter handles unrecoverable errors",
        "auditing": "AuditLogger records validation failures"
      }
    },
    "monitoring": {
      "metrics": {
        "collection": "MetricService captures measurements",
        "enrichment": "Tags add business context",
        "export": "Metrics published to monitoring systems"
      },
      "logging": {
        "generation": "StructuredLogger creates log events",
        "enrichment": "MDC adds context",
        "persistence": "Events written to log files"
      },
      "tracing": {
        "creation": "TraceService starts spans",
        "propagation": "Context passed between services",
        "completion": "Spans closed and exported"
      }
    },
    "security": {
      "authentication": {
        "tokenGeneration": "JwtUtil creates tokens",
        "validation": "Claims extracted and verified",
        "renewal": "Tokens refreshed before expiry"
      },
      "pciData": {
        "masking": "PanMasker protects sensitive data",
        "validation": "LuhnValidator checks card numbers",
        "auditing": "PciAuditService logs access"
      }
    }
  }
} 